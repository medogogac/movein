#!/usr/bin/env python3
# manages links to often used folders
# -*- coding: utf-8 -*-

import argparse
import errno
import glob
import json
import os
import subprocess
import sys
from termcolor import colored

# utility functions
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def vprint(*args, **kwargs):
    if arg.v:
        print(*args, file=sys.stderr, **kwargs)

def error(message):
    eprint(colored("Error:", 'red'), message)
    sys.exit(1)

# Parse arguments
parser = argparse.ArgumentParser(
    description = "A utility that keeps a list of bookmarks to often used directories.",
    epilog = "At least one of -l, -r or bookmark must be specified.")
parser.add_argument("bookmark", nargs='?', default=None,
                    help="the name (letter) of the bookmark")
parser.add_argument("-l", action="store_true",
                    help="list all available bookmarks")
parser.add_argument("-r", action="store_true", help="relink everything")
parser.add_argument("-v", action="store_true", help="verbose output")
parser.add_argument("-f", action="store_true", help="force overwrite an existing bookmark") 

arg = parser.parse_args()
if not arg.l and not arg.r and not arg.bookmark:
    parser.print_help()
    error("Need either -l, -r or bookmark")


try:
    HOMEDIR = os.environ["HOME"]+"/"
    vprint(f" - HOME dir is {HOMEDIR}")
except:
    error("The env variable HOME (which contains the file name of the home dir) needs to be defined.")

try:
    bookmarks_file = os.environ["BOOKMARKS"]
    vprint(f" - BOOKMARKS is {bookmarks_file}")
except:
    error("The system variable BOOKMARKS (which contains the file name of the bookmarks json file) needs to be defined.")

try:
    bookmark_aliases_file = os.environ["BOOKMARKALIASES"]
    vprint(f" - BOOKMARKALIASES is {bookmark_aliases_file}")
except:
    error("The system variable BOOKMARKALIASES (which contains the file name of the aliases file) needs to be defined.")


def symlink_force(target, bookmark):
    try:
        os.symlink(target, bookmark)
        vprint(f"     {bookmark} -> {target}")
    except OSError as e:
        if e.errno == errno.EEXIST:
            os.remove(bookmark)
            os.symlink(target, bookmark)
            vprint(f" {bookmark} -> {target}")
        else:
            raise e

def read_json():
    vprint(f" - reading json from {bookmarks_file}")
    try:
        with open(bookmarks_file, 'r') as rf:
            out = json.load(rf)
    except:
        vprint("No file {bookmarks_file}")
        out = {}
    return(out)


def add_to_dictionary(name, dct):
    vprint(f" - adding the key {name}:{os.getcwd()} to the dictionary")
    if (name in dct) and not arg.f:
        error(f"Name {name} already in dictionary. Use -f to overwrite.")
    current = os.path.relpath(os.getcwd(),HOMEDIR)
    dct[name] = current


def write_json(dct):
    vprint(f" - writing json to {bookmarks_file}.")
    try:
        with open(bookmarks_file, 'w') as wf:
            json.dump(dct, wf, sort_keys=True,
                      indent=4, separators=(',', ': '))
    except:
        error("Could not open {bookmarks_file} for writing.")


def write_symlinks(dct):
    vprint(" - writing symlinks")
    for s, t in dct.items():
        symlink_force(HOMEDIR+t, HOMEDIR+"."+s)


def write_aliases(dct):
    vprint(f" - writing aliases to {bookmark_aliases_file}")
    try:
        with open(bookmark_aliases_file, 'w') as wf:
            wf.write("# aliases for bookmarks\n")
            for s in dct.keys():
                comcd = f"alias cd{s}=\"cd -P ~/.{s}\"\n"
                comgo = f"alias go{s}=\"cd{s} ; go \"\n"
                wf.write(comcd)
                wf.write(comgo)
    except:
        error(f"Could not open {file_name} for writing.")


link_dct = read_json()

if arg.l:
    print("Curently available bookmarks:")
    with open(bookmarks_file, 'r') as rf:
        print(rf.read())
    sys.exit(0)

if arg.bookmark:
    add_to_dictionary(arg.bookmark, link_dct)

write_symlinks(link_dct)
write_json(link_dct)
write_aliases(link_dct)
