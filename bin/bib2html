#!/usr/bin/env perl -w
# converts a bib file into a html and bibtex-html inserts (Perl)

# Various modules
#-----------------

use Text::BibTeX;
use Text::BibTeX::NameFormat;


# sub declarations
#------------------

sub tagify;
sub atagify;
sub formatnames; my $format = new Text::BibTeX::NameFormat ('fvlj',1);
sub utfize;
sub killbrackets;
sub txt2html;


die "Need input bib file!" unless $ARGV[0];

# define which fields we want for different types
my %fields_we_want = (
  article => [ "author", "year", "title", "journal",
	       "volume", "number", "pages"],
  techreport => [ "author", "title", "year", "institution" ],
  incollection => [ "author", "year", "title", "booktitle",
		    "publisher", "address", "note"],
  inproceedings => [ "author", "year", "title", "booktitle",
		     "publisher", "address", "note"],
  unpublished => [ "author", "year", "title", "note",
		   "volume", "number", "pages" ]
);

my @types_we_want = keys %fields_we_want;

# open the file $infile and parse it with Text::BibTeX
$bibfile = new Text::BibTeX::File $ARGV[0];
die "Cannot open $ARGV[0] " if (!$bibfile) ;

while ($entry = new Text::BibTeX::Entry $bibfile)
  {
    # Check wheather the entry is well formed.
    if (!$entry->parse_ok)
      {
	$key=$entry->key();
	print STDERR "Entry $key doesn't parse. Skipping.";
	next;
      };

    $body=tagify($entry);
    $abody=atagify($entry); # destroys parts of $entry;

    print "\n <div class=\"article\">";
    print  "\n  <div class=\"article_body\">";
    print $body;
    print "\n  </div>";
    print "\n  <div class=\"article_clicks\">";
    print $abody;
    print "\n  </div>";
    print "\n </div>";
  };

#############
# subs      #
#############

sub tagify
  {
    $entry=shift;
    my $out="";  my $aux="";  my $type=$entry->type();

    my @fields= @{$fields_we_want{$type}};
    my %values; @values{@fields}=$entry->get(@fields);

    foreach $field (@fields) {
      $aux=$values{$field};
      if ($aux) {
	$aux=formatnames($entry) if ($field=~"author");
	$aux="no. ".$aux if ($field=~"number");
	$aux="vol. ".$aux if ($field=~"volume");
	$aux="pp. ".$aux if ($field=~"pages");
	$aux="(".$aux.")" if ($field=~"year");


	$aux=txt2html(killbrackets(utfize($aux)));

	$out=$out."\n   <span class=\"art_".$field."\">";
	$out=$out." ".$aux;
	$out=$out." </span>";
      }
    }

    return $out;
  }

  sub atagify
    {
      $entry=shift;
      $arxiv=""; $url=""; $doi=""; $out=""; $aux=""; $ext="url";
      $abst=""; $raw="";

      foreach $field ($entry->fieldlist) {

	$aux=$entry->get($field);

	if ($field=~/doi/i) {
	  $doi="\n   <a class=\"doi\"  ";
	  $doi=$doi." href=\"http://dx.doi.org/$aux\">[doi] </a>"
	};

	if ($field=~/arxiv/i) {
	  $arxiv="\n   <a class=\"arxiv\"";
	  $arxiv=$arxiv." href=\"http://arxiv.org/abs/$aux\">[arXiv] </a>"
	};

	if ($field=~/url/i) {
	  if ($aux=~"[.]pdf") {  $ext="pdf" };
	  $url="\n   <a class=\"url\"  ";
	  $url=$url." href=\"$aux\">[$ext] </a>" };

	if ($field=~/abstract/i) {
	  $abstract=$aux;
	}
      };


      # abstract
      if ($abstract) {
	$abst=$abst."\n   <span class=\"ContentA\">";
	$abst=$abst."\n   <div  class=\"abstract\">";
	$abst=$abst."\n   <span class=\"abs_title\">Abstract: </span>";
	$abst=$abst.txt2html(utfize($abstract));
	$abst=$abst."\n   </div>";
	$abst=$abst."\n   </span>";
      }

      # raw bib
      foreach $field ($entry->fieldlist) {
	if ( $field=~/arxiv|url|pdf|abstract/i ) {
	  $entry->delete($field); };

      };

      $raw="\n   <span class=\"ContentB\">";
      $raw=$raw."\n    <div class=\"rawbib\">";
      $raw=$raw."\n".txt2html($entry->print_s)."\n   </div>";
      $raw=$raw."\n   </span>";

      $out=$out.$arxiv.$doi.$url;

      $out=$out."\n   <span class=\"TogglerB\">[bib] </span>";

      $out=$out."\n   <span class=\"TogglerA\">[abstract] </span>"
	unless (!$abstract);

      $out=$out.$abst.$raw;

      return $out;
    }

    # formats author names according to some rule
    sub formatnames
      {

    $mentry=shift;
    @names=$mentry->names('author');

    undef @allnames;
    foreach $name (@names)
    {

	$nameformat=$name->format($format);
	$name=utfize($nameformat);
	push (@allnames, $name);
    }

    $anames= join(', ', @allnames);

    return $anames;
 }

# converts latex diacritics into utf ones
sub utfize
{
    $_= shift;

    s/\{(\w)\}/$1/g;
    s/\\v\W*\{(\w)\}/16a_$1_b16/g;


    s/\\v\W*(\w)/16a_$1_b16/g;
    s/\\\^\W*(\w)/116a_$1_b116/g;
    s/\\\{(\w)\}/119a_$1_b119/g;
    s/\\O/Ø/g;

    s/\\'\W*\{(\w)\}/17a_$1_b17/g;
    s/\\'\W*(\w)/17a_$1_b17/g;

    s/\{1(\d)a_(\w)_b1(\d)\}/1$1a_$2_b1$3/g;

    s/16a_z_b16/ž/g;
    s/116a_o_b116/ô/g;
    s/16a_s_b16/š/g;
    s/16a_c_b16/č/g;
    s/17a_c_b17/ć/g;
    s/16a_d_b16/đ/g;
    s/17a_e_b17/é/g;


    s/16a_Z_b16/Ž/g;
    s/16a_S_b16/Š/g;
    s/16a_C_b16/Č/g;
    s/17a_D_b17/Ć/g;
    s/16a_D_b16/Đ/g;

    return $_;
}

# removes extra curly brackets
sub killbrackets
{
    $_=shift;
    s/[\{\}]//g;
    s/--/-/g;
    return $_;
}

# some simple txt-2-html operations

sub txt2html
{
    $_=shift;
    s/--/-/g;
    s/\}[\n\s]*/\}/g;
    s/\n/<br>\n/g;
    s/(\s){2,}/\&nbsp\&nbsp\ /g;
    s/~/ /g;
    return $_;
}

# raw form of an entry
sub raw
{
  $entry=shift;


}
