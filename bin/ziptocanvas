#!/usr/bin/env python3
# combines a Canvas and Zipgrade files for upload to Canvas
"""This script takes a csv file downloaded from Canvas, and another one
downloaded from ZipGrade and uses them to produce a third csv file which can
be then imported back into Canvas. This third file contains the scores from
the ZipGrade file, together with the required columns from the Canvas file"""

import sys
from termcolor import colored
import math as math
import pandas as pd

# Hardcoded constants
########################

# Canvas extra rows
canvas_rows_to_exclude=['Student, Test','Cudina, Milica']
# These columns must be in for Canvas to accept the upload
canvas_required_cols = ['Student', 'ID', 'SIS User ID', 'SIS Login ID', 'Section']
# This column is kept for unique identification of Students
canvas_other_cols = ['Class ID']
# These rows are junk and should be removed from the Canvas file
canvas_junk_rows = [1] # really means 2nd and 3rd
# The name of the column with the 5-digit id
canvas_id = 'Class ID'

# The column in the zip file with the actual scores
zip_score = 'Percent Correct'
# The column with the 5-digit id in the ZipGrade file
zip_id = 'ZipGrade ID'
# Columns that I really need from the ZipGrade file
zip_required_cols = [zip_score, zip_id,'First Name','Last Name']
# how much to add to all scores
add_to_all_scores = 0


# utility functions
##############################
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def vprint(name,message = ''):
    if arg.v:
        print(colored(name,'green')+message)

def vbanner(name):
    if arg.v:
        print("\n"+colored(name + '\n' + '-'*len(name),'white', attrs = ['bold']))

def bprint(name,message=''):
    print(colored(name,'cyan')+message)

def error(message):
    eprint(colored("Error: ",'red')+message)
    sys.exit(1)

# Parse arguments
#############################
import argparse
parser = argparse.ArgumentParser(description = __doc__ )
parser.add_argument("zip" , help = "the name of the csv file downloaded from ZipGrade")
parser.add_argument("canvas" , help = "the name of the csv file downloaded from Canvas")
parser.add_argument("exam" , help = "the name of exam to fill in the output file (can be just the initial part)")
parser.add_argument("-out" , default = "scores.csv", help = "the name of output csv file (default scores.csv)")
parser.add_argument("-v" , action = "store_true", help = "verbose output")
arg = parser.parse_args()

canvas_file       = arg.canvas
canvas_exam_name  = arg.exam
canvas_other_cols = [ canvas_exam_name ]+canvas_other_cols
zip_file          = arg.zip
all_file          = arg.out

# Reading the canvas file
# Read file (rows 2 and 3 are junk)
vbanner("READING THE CANVAS FILE")
vprint("Reading the cvs file: ",f"{canvas_file}")
# thousands=',' makes pandas read 1,234 as a number and not as a string (object)
canvas_df1 = pd.read_csv(canvas_file, header = 0, skiprows = canvas_junk_rows, thousands=',')
# Exclude rows like "Test Student"
canvas_rows_to_keep=~canvas_df1['Student'].isin(canvas_rows_to_exclude)
vprint("Excluding: ",f"{list(canvas_df1['Student'][~canvas_rows_to_keep])}")

# Exclude all unnecessary columns
full_name={}
for a in canvas_other_cols:
    for col in canvas_df1.columns:
        if a in col:
           full_name[a] = col
           break
if len(full_name) != 2:
    error(f" out of {other_cols} only the following columns could be matched {full_name}") # make sure matches are unique
vprint("Full names of columns: ",f"{full_name}")

canvas_columns_to_keep = canvas_required_cols + [full_name[a] for a in canvas_other_cols]
vprint("Columns to keep: ",f"{canvas_columns_to_keep}")
canvas_df = canvas_df1.loc[canvas_rows_to_keep, canvas_columns_to_keep]
vprint("Number of students: ",f"{len(canvas_df)}")

canvas_df[zip_id] = canvas_df[full_name[canvas_id]].astype(int)

# THE ZIPGRADE FILE
vbanner("READING THE ZIPGRADE FILE")
zip_df1= pd.read_csv(zip_file, header = 0)
vprint("Reading the cvs file: ",f"{zip_file}")
zip_df = zip_df1.loc[:,zip_required_cols]
zip_df['Name'] = zip_df['Last Name']+', '+zip_df['First Name']
zip_df.drop(['Last Name','First Name'], axis = 1, inplace = True)
vprint("Columns to keep: ",f"{list(zip_df.columns)}")
all_df = pd.merge(canvas_df, zip_df, on = zip_id, how = 'outer')
all_df['Name'] = all_df['Name'].fillna("UNKNOWN")
all_df['Student'] = all_df['Student'].fillna("UNKNOWN")
vprint("Number of students: ",f"{len(zip_df)}")

# JOINING
vbanner("JOINING")
for i in all_df.index:
    zip_name = all_df.loc[i,'Name']
    canvas_name = all_df.loc[i,'Student']
    if ('UNKNOWN' in zip_name) or ('UNKNOWN' in canvas_name):
        vprint("Skipping: ",f"Zip name = {zip_name},  Canvas name = {canvas_name}")
        all_df.loc[i,'keep'] = False
    else:
        all_df.loc[i,'keep'] = True
        if zip_name != canvas_name:
            bprint("This should be the same student: ",
                f"Zip name = {zip_name},  Canvas name = {canvas_name}")

all_df = all_df[all_df['keep']]

# Adjusting stores
all_df[full_name[canvas_exam_name]] = all_df[zip_score] + add_to_all_scores

all_cols_to_drop = [zip_id,'Name','Percent Correct','keep',full_name[canvas_id]]
all_df.drop(all_cols_to_drop, axis = 1, inplace = True)

# Output
vbanner("OUTPUTTING")
vprint("Outputting to file: ",f"{all_file}")
vprint("Final number of names: ",f"{len(all_df)}")
all_df.to_csv(all_file, index = False)
