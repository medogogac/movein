#!/usr/bin/env python3
# updates the index.{html,md} files in the papers dir
import os
import sys
import termcolor
from termcolor import colored
import argparse
# needed for parsing bibtex
import bibtexparser
from bibtexparser.bparser import BibTexParser
from bibtexparser.bibdatabase import BibDatabase
from bibtexparser.customization import convert_to_unicode
# needed for finding close matches of missing entries (standard library)
import difflib
# needed for argument parsing
from os.path import isfile, join
from os.path import expanduser, expandvars
from pathlib import Path
import re


####################################################
# Argument parsing and default values
####################################################

# default values; expanduser() makes sure that ~ and environt
# variables get expanded correctly
papers_dir=expandvars("$PAPERSDIR")
output_file_name=papers_dir+"/index.md" # html is produced from md
bib_file_name=expandvars("$BIBDIR/mybib.bib")
archivetitle="An Article Anarchive"

# argument parsing
argumentparser = argparse.ArgumentParser(description="Walk directories, collect all pdf/djvu/... "
                                                     "files, look them up in a bibfile, and create "
                                                     "md and html files with links")
argumentparser.add_argument("-v","--verbose",
  help="verbose output", action="store_true")
argumentparser.add_argument("-p","--path",
  help='the top papers path ; default value: '+papers_dir)
argumentparser.add_argument("-b","--bibfile",
  help='the input bibtex file name; default value: '+bib_file_name)
argumentparser.add_argument("-o","--output",
  help='the output file name; default value: '+output_file_name)
argumentparser.add_argument("-t","--title",
  help='the document title; default value: '+archivetitle)

args=argumentparser.parse_args()

if args.path: papers_dir=args.path
if args.output: output_file_name=args.output+'.md'
if args.bibfile: bib_file_name=args.bibfile
if args.title: archivetitle=args.title

if args.verbose:
    print("papers dir path : "+papers_dir)
    print("output file     : "+output_file_name)
    print("bibtex file     : "+bib_file_name)
    print("title           : "+archivetitle)

####################################################
# Functions
####################################################

# reads in the bibtex file and convert it to a dictionary
# makes sure everything is in unicode
def bibtex_to_dictionary(bibfile):
    print("Parsing the bib file ... ", end="", flush=True)
    with open(bibfile,'r') as bibtex_file:
        parser = BibTexParser()
        parser.ignore_nonstandard_types = False
        parser.customization = convert_to_unicode
        # bib_database is an internal data structure for bibtexparser, it
        # contains info about preamble parts, etc.
        bib_database = bibtexparser.load(bibtex_file, parser=parser)
        # next we need to extracts all bibtex records in a form a dictionary
        # with bibtex keys (strings) as keys. Each record is iteself
        # a dictionary with (string) keys such as "title", "author"
        print(" Done.")
        return(bib_database.entries_dict)

# formats a bibtex record into Markdown, with link
def format_record (record, link_name, link):
    # Check if title and author fields exist
    title = "No Title"
    if "title" in record:
        title=record["title"]
    author="No Author"
    if "editor" in record:
        author=record["editor"]
    if "author" in record:
        author=record["author"]

    # Markdown formatting: ** ** bold, * *, ital, [] link, 1. lists
    outtext="\n 1. **{}** *{}* [{}]({})".format(author, title, link_name, link)

    # here is a dictionary with replacements (to make things more beautiful)
    repl={ "{":"", "}":"" }

    # apply all the replacements from repl
    for fr in repl:
        outtext=outtext.replace(fr,repl[fr])
    return(outtext)


# formats the area title (all lower case and _ -> space)
def format_area (ttl):
    #  fttl=re.sub(r'(\d+)_',r'\1. ',ttl)
     fttl=re.sub(r'(\d+)_',r'',ttl)
     fttl=fttl.replace('_',' ').lower();
     return("\n\n# {}".format(fttl))
     o

# formats the subarea title (all lower case and _ -> space)
def format_subarea (ttl):

    fttl=ttl.replace('_',' ').lower();

    return("\n\n## {}".format(fttl))

# formats the link to an area (all lower case and _ -> space)
def link_area(ttl):
    ttl = re.sub(r'(\d+)_', r'', ttl)
    bttl = ttl.replace('_', ' ').lower()
    fttl = ttl.replace('_', '-').lower()

    return("\n\n - **[{}](#{})**\n\n".format(bttl, fttl))

# formats the link to a subarea (all lower case and _ -> space)
def link_subarea(ttl):
    
    bttl = ttl.replace('_', ' ').lower()
    fttl = ttl.replace('_', '-').lower()

    return("\n     - [{}](#{})".format(bttl, fttl))

# takes a file name (like RevYor91.pdf with an extension) and returns a
# formatted Markdown field by looking into bib
def name_to_field(book_file, bib_dict, fullpath):
     book_key=book_file.split('.')[0];
     if book_key in list(bib_dict):
         return(format_record(mybib[book_key],book_file,fullpath))
     else:
         matches=difflib.get_close_matches(book_key, bib_dict.keys())
         print("  "+colored(book_file,'red')+" - "+str(matches))
         return("")

# returns a dictionary whose keys are subarea (subdirs of subdirs of pdir) and
# values are lists of files in each; and another whose keys are files
# and values containing direct
def create_file_dictionary(pdir):
    filedict={}
    dirdict={}
    for dirpath, dirnames, files in os.walk(pdir, topdown=True):
        if not dirnames:
            current = Path(dirpath)
            area = current.parent.parts[-1]
            subarea = current.parts[-1]
            if (area not in filedict):
                filedict[area]={}
            filedict[area][subarea]=files
            for file in files:
                dirdict[file]=area+"/"+subarea+"/"+file;
    return(filedict, dirdict)

## create the output string
def list_and_format(filedict, dirdict, bib):
    # links on top
    out = ""
    for area in sorted(filedict.keys()):
        out+=link_area(area)
        for subarea in sorted(filedict[area].keys()):
            out += link_subarea(subarea)

    # files
    books_total=0
    for area in sorted(filedict.keys()):
        print(colored(area,'green'))
        out+=format_area(area)
        for subarea in sorted(filedict[area].keys()):
            out+=format_subarea(subarea)
            print(" "+colored(subarea,'cyan'), end=": ")
            books_subarea = 0
            for book in sorted(filedict[area][subarea]):
                out+=name_to_field(book,bib,dirdict[book])
                books_subarea+=1 
                books_total+=1
            print("  ", colored(books_subarea,'red'))
    print(colored("Total", 'yellow'), end=": ")
    print(colored(books_total,'red'))
    return(out)

####################################################
# The main portion
####################################################

# read and convert bibtex entry from bib_file_name
mybib=bibtex_to_dictionary(bib_file_name)

# create a dictionary of all book files
filedir, dirdict = create_file_dictionary(papers_dir)


# create the output string
out=list_and_format(filedir, dirdict, mybib)

# open the output file and write the title (in Markdown)
with open(output_file_name,'w') as outfile:
    outfile.write(out)

# Convert Markdown into html -s flag is to make html self-contained
# (in particular, unicode characters show correctly)
md_file=output_file_name
html_file=md_file.replace('.md','.html')
pandoc_command = 'pandoc -s -c style.css --metadata title='+'"'+archivetitle+'"'
os.system( pandoc_command + " " + md_file + ' > ' + html_file)
